
/*
Calculates the position of a particle that bounces within a range.
Can be combined in 2D or 3D.
*/
float utils_bounce (in vec2 range, in float start, in float vel, in float time) {
	if (vel == 0.0) {
		return start;
	}
	
	float r = range.y - range.x;
	if (r == 0.0) {
		return range.x;	
	}
	
	start = (start - range.x) / r;
	vel = vel / r;
	float t0 = (1.0 - start) / vel;
	float ti = 1.0 / vel;
	float m = mod ((time - t0) / ti, 2.0);
	m = m > 1.0 ? 2.0 - m : m;
	return m * r + range.x;
}

/*
Returns true if a coordinate is within the radius of a circle.
*/
bool utils_circle (vec2 center, float radius, vec2 pos) {
	vec2 d = pos - center;
	return length (d) < radius;
}

/*
Returns true if a coordinate is within the range of a donut.
*/
bool utils_donut (vec2 center, vec2 range, vec2 pos) {
	vec2 d = pos - center;
	float len = length (d);
	return len >= range.x && len < range.y;
}

/*
Returns interpolated color given by two control points and colors.
*/
vec4 utils_gradient(
	in vec2 xy,
	in vec4 color1, 
	in vec4 color2,
	in vec2 pos1,
	in vec2 pos2) 
{
	vec2 normal = normalize(pos2 - pos1);
	float len = length(pos2 - pos1);
	float f = (dot(xy, normal) - dot(pos1, normal)) / len;
	return mix(color1, color2, clamp(f, 0.0, 1.0));
}

/*
Returns the position of fragment coordination centered at screen.
The height maps from -0.5 to 0.5 and the width is adjusted accordingly.
*/
vec2 utils_position (vec2 resolution) {
	vec2 pos = gl_FragCoord.xy / resolution.xy - vec2(0.5, 0.5);
	pos.x *= resolution.x / resolution.y;
	return pos;
}

/*
Maps from one scale to another.
*/
float utils_remap(
	in float x,
	in float start0,
	in float end0,
	in float start1,
	in float end1)
{
	float f = (x - start0) / (end0 - start0);
	return start1 + f * (end1 - start1);
}

/*
Maps from {-infinity, infinity}
to {0, 1}.
*/
float utils_sigmoid (float x) {
	return 1.0 / (1.0 + exp(-x));	
}
